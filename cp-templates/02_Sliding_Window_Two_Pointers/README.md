
# Sliding Window & Two Pointers (–°–∫–æ–ª—å–∑—è—â–µ–µ –æ–∫–Ω–æ –∏ –¥–≤–∞ —É–∫–∞–∑–∞—Ç–µ–ª—è)

## –ß—Ç–æ —ç—Ç–æ
–¢–µ—Ö–Ω–∏–∫–∞ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏ –ø–µ—Ä–µ–±–æ—Ä–∞, –≥–¥–µ –º—ã –∏—Å–ø–æ–ª—å–∑—É–µ–º **–¥–≤–∞ —É–∫–∞–∑–∞—Ç–µ–ª—è (left, right)**, —á—Ç–æ–±—ã –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏ –≤—ã–±–∏—Ä–∞—Ç—å –ø–æ–¥–º–∞—Å—Å–∏–≤ –∏–ª–∏ –ø–æ–¥—Å—Ç—Ä–æ–∫—É, —É–¥–æ–≤–ª–µ—Ç–≤–æ—Ä—è—é—â—É—é —É—Å–ª–æ–≤–∏—é.  
–í–º–µ—Å—Ç–æ –ø—Ä–æ–≤–µ—Ä–∫–∏ –≤—Å–µ—Ö –≤–æ–∑–º–æ–∂–Ω—ã—Ö –ø–æ–¥–æ—Ç—Ä–µ–∑–∫–æ–≤ (O(n¬≤)), –º—ã –¥–≤–∏–≥–∞–µ–º —É–∫–∞–∑–∞—Ç–µ–ª–∏ —É–º–Ω–æ, –¥–æ–±–∏–≤–∞—è—Å—å **O(n)**.

---

## –í–∏–¥—ã
- **Two Pointers** ‚Äî –æ–±—ã—á–Ω–æ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –¥–ª—è **–æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –º–∞—Å—Å–∏–≤–æ–≤** –∏–ª–∏ –∑–∞–¥–∞—á —Ç–∏–ø–∞ *"—Å–æ–π—Ç–∏—Å—å –∏–∑ –∫–æ–Ω—Ü–æ–≤"*.
- **Sliding Window** ‚Äî –¥–ª—è –ø–æ–¥–º–∞—Å—Å–∏–≤–æ–≤/–ø–æ–¥—Å—Ç—Ä–æ–∫, –≥–¥–µ –º—ã –∏—â–µ–º **–Ω–∞–∏–±–æ–ª—å—à–∏–π/–Ω–∞–∏–º–µ–Ω—å—à–∏–π –¥–∏–∞–ø–∞–∑–æ–Ω**, —É–¥–æ–≤–ª–µ—Ç–≤–æ—Ä—è—é—â–∏–π —É—Å–ª–æ–≤–∏—é.

---

## –ó–∞—á–µ–º –Ω—É–∂–Ω–æ
- –ü–æ–∏—Å–∫ –ø–æ–¥–º–∞—Å—Å–∏–≤–∞ —Å –Ω—É–∂–Ω—ã–º —Å–≤–æ–π—Å—Ç–≤–æ–º (—Å—É–º–º–∞, –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ, —É–Ω–∏–∫–∞–ª—å–Ω–æ—Å—Ç—å –∏ —Ç.–¥.)
- –ù–∞—Ö–æ–∂–¥–µ–Ω–∏–µ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–π/–º–∏–Ω–∏–º–∞–ª—å–Ω–æ–π –¥–ª–∏–Ω—ã –ø–æ–¥–º–∞—Å—Å–∏–≤–∞
- –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ–¥—Å—Ç—Ä–æ–∫ –∏ –ø–æ–¥–º–∞—Å—Å–∏–≤–æ–≤ –±–µ–∑ –¥—É–±–ª–∏–∫–∞—Ç–æ–≤, —Å –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ–º –∏ —Ç.–¥.

---

## –¢–∏–ø–æ–≤—ã–µ —à–∞–±–ª–æ–Ω—ã

### üîπ Two Pointers (–Ω–∞ –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ–º –º–∞—Å—Å–∏–≤–µ)
```cpp
int i = 0, j = nums.size() - 1;

while (i < j) {

    int sum = nums[i] + nums[j];

    if (sum == target) return {i, j};
    else if (sum < target) i++;
    else j--;

}
```
### üîπ Sliding Window (–ø–µ—Ä–µ–º–µ–Ω–Ω–æ–µ –æ–∫–Ω–æ)
```cpp
int l = 0;
for (int r = 0; r < nums.size(); r++) {
    // –¥–æ–±–∞–≤–∏—Ç—å nums[r] –≤ –æ–∫–Ω–æ
    
    while (—É—Å–ª–æ–≤–∏–µ –Ω–∞—Ä—É—à–µ–Ω–æ) {
        // —É–±—Ä–∞—Ç—å nums[l] –∏–∑ –æ–∫–Ω–∞
        l++;
    }
    
    // –æ–±–Ω–æ–≤–∏—Ç—å –æ—Ç–≤–µ—Ç
}
```

## –û—à–∏–±–∫–∏

- –ó–∞–±—ã—Ç—å –æ–±–Ω–æ–≤–∏—Ç—å `l` –ø—Ä–∏ –Ω–∞—Ä—É—à–µ–Ω–∏–∏ —É—Å–ª–æ–≤–∏—è –æ–∫–Ω–∞.
- –ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω–æ –æ–±–Ω–æ–≤–ª—è—Ç—å –æ—Ç–≤–µ—Ç (–≤–Ω—É—Ç—Ä–∏ –∏–ª–∏ —Å–Ω–∞—Ä—É–∂–∏ —Ü–∏–∫–ª–∞).
- –°—á–∏—Ç–∞—Ç—å –æ–∫–Ω–æ –ø–æ `r - l`, –∞ –Ω–µ `r - l + 1`.
- –ù–µ —Ä–∞–∑–ª–∏—á–∞—Ç—å —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ –æ–∫–Ω–æ (—Ñ–∏–∫—Å. —Ä–∞–∑–º–µ—Ä) –∏ –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–µ (–ø–æ —É—Å–ª–æ–≤–∏—é).

## –ü—Ä–∏–º–µ—Ä—ã —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏

üìÑ [–†–µ—à–µ–Ω–∏–µ ‚Üí](./Examples.cpp)

### Leetcode 167. Two Sum II - Input Array Is Sorted (Two Pointers)

- Given a array of integers numbers that is already sorted in non-decreasing order, find two numbers such that their sum target number. Return the positions of the two numbers
- **–ò–¥–µ—è:** –£–º–µ–Ω—å—à–∞–µ–º –ø—Ä–∞–≤—ã–π —É–∫–∞–∑–∞—Ç–µ–ª—å, –µ—Å–ª–∏ —Å—É–º–º–∞ –±–æ–ª—å—à–µ `target`, –∏–Ω–∞—á–µ –¥–≤–∏–≥–∞–µ–º –ª–µ–≤—ã–π —É–∫–∞–∑–∞—Ç–µ–ª—å
- **–ü—Ä–∏–º–µ—Ä—ã:**
  ```
  Example 1:
  Input: numbers = [2,7,11,15], target = 9
  Output: [1,2]
  Explanation: The sum of 2 and 7 is 9. Therefore, index1 = 1, index2 = 2. We return [1, 2].

  Example 2:
  Input: numbers = [2,3,4], target = 6
  Output: [1,3]
  Explanation: The sum of 2 and 4 is 6. Therefore index1 = 1, index2 = 3. We return [1, 3].
  ```

### Leetcode 3. Longest Substring Without Repeating Characters (Sliding Window)

- Given a string s, find the length of the longest substring without duplicate characters.
- **–ò–¥–µ—è:** —Ä–∞—Å—à–∏—Ä—è–µ–º –æ–∫–Ω–æ, –ø–æ–∫–∞ –±—É–∫–≤—ã –Ω–µ –¥—É–±–ª–∏—Ä—É—é—Ç—Å—è, —Å—É–∂–∞–µ–º –æ–∫–Ω–æ, –ø–æ–∫–∞ –¥—É–±–ª—å –Ω–µ —É–π–¥–µ—Ç
- **–ü—Ä–∏–º–µ—Ä—ã:**
  ```
  Example 1:
  Input: s = "abcabcbb"
  Output: 3
  Explanation: The answer is "abc", with the length of 3. Note that "bca" and "cab" are also correct answers.

  Example 2:
  Input: s = "pwwkew"
  Output: 3
  Explanation: The answer is "wke", with the length of 3.
  Notice that the answer must be a substring, "pwke" is a subsequence and not a substring.
  ```

### Leetcode 1004. Max Consecutive Ones III (Sliding Window)

- Given a binary array nums and an integer k, return the maximum number of consecutive 1's in the array if you can flip at most k 0's.
- **–ò–¥–µ—è:** —Ä–∞—Å—à–∏—Ä—è–µ–º –æ–∫–Ω–æ –ø–æ–∫–∞ `k>0`, —Å—É–∂–∞–µ–º –æ–∫–Ω–æ –ø–æ–∫–∞ —É—Å–ª–æ–≤–∏–µ –Ω–µ –±—É–¥–µ—Ç –≤—ã–ø–æ–ª–Ω—è—Ç—å—Å—è
- **–ü—Ä–∏–º–µ—Ä—ã:**
  ```
  Example 1:
  Input: nums = [1,1,1,0,0,0,1,1,1,1,0], k = 2
  Output: 6
  Explanation: [1,1,1,0,0,1,1,1,1,1,1]

  Example 2:
  Input: nums = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], k = 3
  Output: 10
  Explanation: [0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1]
  ```
















